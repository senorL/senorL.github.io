<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="函数指针定义方式：类型名(*指针变量名)(参数类型1,参数类型2)。例如：int (* pf)(int, char)意思是pf为函数指针，所指向的函数，返回值类型为int，有两个参数，第一个是int型，第二个是char类型。使用方法：用一个原型匹配的函数的名字给一个函数指针赋值，通过该指针调用它所指向的函数，写作：函数指针名（实参表）#include &lt;iostream&gt;#includ">
<meta property="og:type" content="article">
<meta property="og:title" content="零基础学习c程序（三）—— c++程序设计">
<meta property="og:url" content="http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="senor">
<meta property="og:description" content="函数指针定义方式：类型名(*指针变量名)(参数类型1,参数类型2)。例如：int (* pf)(int, char)意思是pf为函数指针，所指向的函数，返回值类型为int，有两个参数，第一个是int型，第二个是char类型。使用方法：用一个原型匹配的函数的名字给一个函数指针赋值，通过该指针调用它所指向的函数，写作：函数指针名（实参表）#include &lt;iostream&gt;#includ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/12/01/z0HnR1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/12/01/z0cJcd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/12/01/z02hpF.png">
<meta property="article:published_time" content="2022-11-22T10:09:30.000Z">
<meta property="article:modified_time" content="2023-07-16T03:00:56.383Z">
<meta property="article:author" content="senor">
<meta property="article:tag" content="c程序学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/12/01/z0HnR1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>零基础学习c程序（三）—— c++程序设计</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/senorl">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/02/12/week5/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&text=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&is_video=false&description=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=零基础学习c程序（三）—— c++程序设计&body=Check out this article: http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&name=零基础学习c程序（三）—— c++程序设计&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&t=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E2%80%9D-amp-%E2%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">按位与”&amp;”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96%E2%80%9D-%E2%80%9D"><span class="toc-number">2.2.</span> <span class="toc-text">按位或”|”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E2%80%9D-%E2%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">按位异或”^”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%9D%9E%E2%80%9D-%E2%80%9D"><span class="toc-number">2.4.</span> <span class="toc-text">按位非”~”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9D-lt-lt-%E2%80%9D"><span class="toc-number">2.5.</span> <span class="toc-text">左移运算符”&lt;&lt;”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-gt-gt-%E2%80%9D"><span class="toc-number">2.6.</span> <span class="toc-text">右移运算符 “&gt;&gt;”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">const 用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">内联函数与重载函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数的缺省参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AE%A2%E8%A7%82%E4%BA%8B%E7%89%A9%E6%8A%BD%E8%B1%A1%E5%87%BA%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">6.1.1.</span> <span class="toc-text">从客观事物抽象出类的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">对象的内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">访问类的成员变量和成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%99%E6%B3%95"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">其他写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.2.</span> <span class="toc-text">类成员的可访问范围</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Week3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">Week3 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">内联成员函数和重载成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">复制构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">7.3.1.</span> <span class="toc-text">使用的三种情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">类型转换构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">静态成员变量和静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-number">7.7.</span> <span class="toc-text">成员对象和封闭类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.7.2.</span> <span class="toc-text">调用顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">7.8.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">7.8.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">7.8.2.</span> <span class="toc-text">友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">7.9.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">7.10.</span> <span class="toc-text">常量对象、常量成员函数、常引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.10.1.</span> <span class="toc-text">常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.10.2.</span> <span class="toc-text">常量成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">7.10.3.</span> <span class="toc-text">常引用</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        零基础学习c程序（三）—— c++程序设计
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">senor</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-22T10:09:30.000Z" class="dt-published" itemprop="datePublished">2022-11-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/c%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/" rel="tag">c程序学习</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>定义方式：类型名(<code>*</code>指针变量名)(参数类型1<code>,</code>参数类型2)。<br>例如：<code>int (* pf)(int, char)</code><br>意思是<code>pf</code>为函数指针，所指向的函数，返回值类型为<code>int</code>，有两个参数，第一个是<code>int</code>型，第二个是<code>char</code>类型。<br>使用方法：用一个<strong>原型</strong>匹配的函数的名字给一个函数指针赋值，通过该指针调用它所指向的函数，写作：函数指针名（实参表）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void PrintMin(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a &lt; b)</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;%d&quot;, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void( * pf)(int, int);</span><br><span class="line">    int x = 4, y = 5;</span><br><span class="line">    pf = PrintMin;</span><br><span class="line">    pf(x, y);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为什么要用函数指针调用函数？<br>其中一种用途就是排序。<br><a target="_blank" rel="noopener" href="https://imgse.com/i/z0HnR1"><img src="https://s1.ax1x.com/2022/12/01/z0HnR1.png" alt="z0HnR1.png"></a><br>其中的<code>pfCompare</code>是自己编写的比较函数。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>用于对整数类型(int, char, long等)变量中的 某一位 （bit)或者 若干位 进行操作</p>
<h2 id="按位与”-amp-”"><a href="#按位与”-amp-”" class="headerlink" title="按位与”&amp;”"></a>按位与”&amp;”</h2><p>将参与运算的两操作数各对应的<strong>二进制位</strong>进行与操作，只有两个二进位都是<code>1</code>时候才输出<code>1</code>。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21 &amp; 18 = 16</span><br><span class="line">21</span><br><span class="line">10101</span><br><span class="line">18</span><br><span class="line">10010</span><br><span class="line">10000</span><br><span class="line">16</span><br></pre></td></tr></table></figure><br>作用：将某变量中的某位清<code>0</code>且保留其他位不变，也可以用来获取变量中的某一位。<br>例如 如果需要将<code>int</code>型变量<code>n</code>的低<code>8</code>位全换成<code>0</code>，而其余位不变，可以执行：<br><code>n = n &amp; 0xffffff00</code>.<br>如果<code>n</code>是<code>short</code>型，那么：<br><code>n = n &amp; 0xff00</code>.  </p>
<p>判断一个<code>int</code>型变量<code>n</code>的第<code>7</code>位是否为<code>1</code>；<br><code>n &amp; 0x80</code>是否等于<code>0x80</code>.  </p>
<h2 id="按位或”-”"><a href="#按位或”-”" class="headerlink" title="按位或”|”"></a>按位或”|”</h2><p>将参与运算的两操作数各对应的 二进制位 进行与操作，只有两个二进位都是0时候才输出0<br>21 | 18 = 23<br>21 | 18 = 10111<br>将某变量中的某些位置变1且保留其他位不变<br>例如 如果需要将int型变量n的低8位全换成0，而其余位不变，可以执行：<br>n |= 0xff</p>
<h2 id="按位异或”-”"><a href="#按位异或”-”" class="headerlink" title="按位异或”^”"></a>按位异或”^”</h2><p>将参与运算的两操作数各对应的 二进制位 进行与操作，只有两个二进位不相同时，结果对应的二进制位才是1，否则为0<br>21 ^ 18 = 7<br>00111<br>将某变量中的某些位取反，且保留其他位不变<br>例如 如果需要将int型变量n的低8位取反，而其余位不变，可以执行：<br>n ^= 0xff<br>0xff 1111 1111<br>特点：如果a ^ b = c, 那么就有 c ^ b = a以及 c ^ a = b.<br>异或运算能实现不通过临时变量，就能交换两个变量的值：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5, b = 7;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure></p>
<h2 id="按位非”-”"><a href="#按位非”-”" class="headerlink" title="按位非”~”"></a>按位非”~”</h2><p>单目运算符，将操作数二进制位<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>：<br><code>~21 = 0xffffffea</code>.</p>
<h2 id="左移运算符”-lt-lt-”"><a href="#左移运算符”-lt-lt-”" class="headerlink" title="左移运算符”&lt;&lt;”"></a>左移运算符”&lt;&lt;”</h2><p><code>a &lt;&lt; b</code>的值是：将<code>a</code>各个二进位全部左移<code>b</code>位后得到的值。高位丢弃，低位补<code>0</code>，<code>a</code>的值不会因为运算而改变。<br>注意：左移<code>1</code>位，就等于是乘以<code>2</code>，左移<code>n</code>位，就等于是乘以 $2^{n}$ ,左移操作比乘法快的多！ </p>
<h2 id="右移运算符-“-gt-gt-”"><a href="#右移运算符-“-gt-gt-”" class="headerlink" title="右移运算符 “&gt;&gt;”"></a>右移运算符 “&gt;&gt;”</h2><p><code>a &gt;&gt; b</code>的值是：将<code>a</code>各二进位全部右移<code>b</code>位后得到的值。右移后，移出最右边的位就被丢弃。<code>a</code>的值不因运算而改变。<br>对于有符号数，在右移时，符号位将一起移动，如果原符号位为<code>1</code>，则右移时高位就补充<code>1</code>，反之同理。<br>右移<code>n</code>为，就相当于左操作数除以 $2^{n}$ ，将结果往小取整。<br>注意：-1.6取整为-2。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>类型名<code>&amp;</code>引用名<code>=</code>某个变量名。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n = 4;</span><br><span class="line">int &amp; r = n; // r 引用了n, r的类型为int &amp;</span><br></pre></td></tr></table></figure><br>引用等价于这个变量，<strong>相当于该变量的别名</strong></p>
<ul>
<li>定义引用时一定要将其初始化成引用某个变量</li>
<li>初始化后，它就一直引用该变量，不会再引用别的变量</li>
<li>引用只能引用变量，不能引用常量和表达式</li>
</ul>
<p>例子:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap(int &amp; a, int &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int n1, n2;</span><br><span class="line">swap(n1, n2);</span><br></pre></td></tr></table></figure><br>引用作为函数返回值，可以对一个函数返回值赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n = 4;</span><br><span class="line">int &amp; SetValue()</span><br><span class="line">&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SetValue() = 40;</span><br><span class="line">    cout &lt;&lt; n;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// n = 40</span><br></pre></td></tr></table></figure>
<p>常引用：在定义引用前加<code>const</code>，不能通过常引用修改其引用的内容。<br><code>T &amp;</code>类型的引用或者<code>T</code>类型的变量可以用来初始化<code>const T &amp;</code>类型的引用。  </p>
<p><code>const T</code>类型的常变量和<code>const  T &amp;</code>类型的引用不能用来初始化<code>T &amp;</code>的引用，除非进行强制类型转换。</p>
<h2 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h2><ol>
<li>定义常量</li>
<li><p>定义常量指针</p>
<ul>
<li>不可以通过常量指针修改其指向内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n, m;</span><br><span class="line">const * p = &amp; n;</span><br><span class="line">* p = 5; // 编译出错</span><br><span class="line">n = 4; //ok</span><br><span class="line">p = &amp;m; //ok, 常量指针的指向可以变化</span><br></pre></td></tr></table></figure>
<ul>
<li>不能把常量指针赋值给非常量指针， 反过来可以。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int * p1; int * p2;</span><br><span class="line">p1 = p2; // ok</span><br><span class="line">p2 = p1; // error </span><br><span class="line">p2 = (int *)p1; // ok,强制类型转换</span><br></pre></td></tr></table></figure></li>
<li>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容。</li>
<li>常引用。</li>
</ul>
</li>
</ol>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><ol>
<li>用<code>new</code>运算符实现动态内存分配。<br>分配给一个变量<br><code>P = new T</code><br><code>T</code>是类型名， <code>P</code>是类型为<code>T *</code>的指针。<br>动态分配出<code>sizeof(T)</code>字节的空间，将该内存空间的起始地址赋值给<code>P</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * pn;</span><br><span class="line">pn = new int;</span><br><span class="line">* pn = 5;</span><br></pre></td></tr></table></figure></li>
<li>分配一个数组<br><code>P = new T[N]</code><br><code>T</code> : 类型名。<br><code>P</code> : 类型为<code>T *</code>的指针。<br><code>N</code> : 要分配的数组元素的个数，可以是整形表达式。<br>动态分配出<code>N * sizeof(T)</code>字节的空间， 将该内存空间的起始地址赋值给<code>P</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * pn;</span><br><span class="line">int i = 5;</span><br><span class="line">pn = new int[i * 20];</span><br><span class="line">pn[0] = 20;</span><br><span class="line">pn[99] = 30;</span><br></pre></td></tr></table></figure></li>
<li><p><code>new</code>运算符的返回值类型<br><code>new T</code><br><code>new T[n]</code><br>返回值类型<code>T *</code><br><code>int * p = new int</code></p>
</li>
<li><p>用<code>new</code>动态分配的内存空间，一定要用<code>delete</code>运算符释放掉<code>int *p = new int</code>。<br><code>*p = 5</code><br><code>delete p</code></p>
</li>
</ol>
<p><code>delete</code>指针：必须指向<code>new</code>出来的空间。 </p>
<p>删除数组的方法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p = new int[20];</span><br><span class="line">p[0] = 1;</span><br><span class="line">delete[] p;</span><br></pre></td></tr></table></figure></p>
<h1 id="内联函数与重载函数"><a href="#内联函数与重载函数" class="headerlink" title="内联函数与重载函数"></a>内联函数与重载函数</h1><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p><strong>处理内联函数的调用语句时，直接将整个函数的代码插入到调用语句处，不会产生调用函数的语句。</strong><br>在函数定义前加<code>inline</code>关键字</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，然而<strong>参数个数</strong>或<strong>参数类型</strong>不同，叫做函数的重载。<br>重载关系：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int max (double f1,double f2)&#123;&#125;</span><br><span class="line">int max (int n1, int n2)&#123;&#125;</span><br><span class="line">int max (int n1, int n2, int n3)&#123;&#125;</span><br></pre></td></tr></table></figure><br>用处：命名变得更简单，根据语句实参个数和类型的不同来判断调用。<br>注意： 只有返回值类型的不同的函数不叫重载，叫做重复定义。</p>
<h1 id="函数的缺省参数"><a href="#函数的缺省参数" class="headerlink" title="函数的缺省参数"></a>函数的缺省参数</h1><p>定义函数时可以让<strong>最右边的连续</strong>若干个参数有缺省值，调用函数的时候，若相应位置不写参数，参数就是缺省值。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func(int x1, int x2 = 2, int x3 = 3)&#123;&#125;</span><br><span class="line">func(10);//等于func(10, 2, 3)</span><br><span class="line">func(10, 8);//等于func(10, 8, 3)</span><br><span class="line">func(10, , 8);//错误，只能最右边的连续若干个参数缺省</span><br></pre></td></tr></table></figure><br>用处：提高程序的可扩充性。</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的定义：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">    访问范围说明符：</span><br><span class="line">    成员变量1</span><br><span class="line">    成员变量2</span><br><span class="line">    ...</span><br><span class="line">    成员函数声明1</span><br><span class="line">    成员函数声明2</span><br><span class="line">    访问范围说明符：</span><br><span class="line">    更多成员变量</span><br><span class="line">    更多成员函数声明</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="从客观事物抽象出类的例子"><a href="#从客观事物抽象出类的例子" class="headerlink" title="从客观事物抽象出类的例子"></a>从客观事物抽象出类的例子</h3><p>类是一个带有函数的结构体。<br><a target="_blank" rel="noopener" href="https://imgse.com/i/z0cJcd"><img src="https://s1.ax1x.com/2022/12/01/z0cJcd.png" alt="z0cJcd.png"></a><br>例如：想求一个矩形的所有信息？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CRectangle &#123;</span><br><span class="line">	public:</span><br><span class="line">	int w, h;</span><br><span class="line">	void nit(int w_, int h_) &#123;</span><br><span class="line">		w = w_; h = h_;</span><br><span class="line">	&#125;</span><br><span class="line">	int Area() &#123;</span><br><span class="line">		return w * h;</span><br><span class="line">	&#125;</span><br><span class="line">	int Perimeter() &#123;</span><br><span class="line">		return 2 * (w + h);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int w, h;</span><br><span class="line">	CRectangle r; // r 是一个对象</span><br><span class="line">	cin &gt;&gt; w &gt;&gt; h;</span><br><span class="line">	r.nit(w, h);</span><br><span class="line">	cout &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt; r.Perimeter();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类定义的变量 -&gt; 类的实例 -&gt; “对象”。   </p>
<h4 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h4><p>对象的大小 = 所有成员变量的大小之和。<br>例如：<code>CRectangle</code>类的对象，<code>sizeof(CRectangle) = 8</code>.<br>每个对象各有自己独立的空间。<br>对象之间可以用 = 来赋值。</p>
<h4 id="访问类的成员变量和成员函数"><a href="#访问类的成员变量和成员函数" class="headerlink" title="访问类的成员变量和成员函数"></a>访问类的成员变量和成员函数</h4><ol>
<li>对象名<code>.</code>成员名<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">r1.w = 5;</span><br><span class="line">r2.nit(3, 4);</span><br></pre></td></tr></table></figure></li>
<li>指针<code>-&gt;</code>成员名<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">CRectangle * p1 = &amp; r1;</span><br><span class="line">CRectangle * p2 = &amp; r2;</span><br><span class="line">p1 -&gt; w = 5;</span><br><span class="line">p2 -&gt; nit(3, 4) // nit 作用在p2指向的对象上</span><br></pre></td></tr></table></figure></li>
<li>引用名<code>.</code>成员名<br><strong>引用就是变量的别名</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CRectangle r2;</span><br><span class="line">CRectangle &amp; rr = r2;</span><br><span class="line">rr.w = 5;</span><br><span class="line">rr.nit(3, 4); // rr的值变了， r2的值也变</span><br></pre></td></tr></table></figure>
<h4 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h4></li>
<li>另一种输出结果的方式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PrintRectangle(CRectangle &amp; r) &#123;</span><br><span class="line">    cout &lt;&lt; r.Area() &lt;&lt; &quot;,&quot; &lt;&lt; r.Rerimeter();</span><br><span class="line">&#125;</span><br><span class="line">CRectangle r3;</span><br><span class="line">r3.nit(3, 4);</span><br><span class="line">PrintRectangle(r3);</span><br></pre></td></tr></table></figure></li>
<li>类的成员函数的另一种写法：<br>成员函数体和类的定义分开写<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CRectangle &#123;</span><br><span class="line">	public:</span><br><span class="line">	int w, h;</span><br><span class="line">	int Area();</span><br><span class="line">	int Perimeter();</span><br><span class="line">	void nit(int w_, int h_);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
此处仅声明成员函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int CRectangle::Area() &#123;</span><br><span class="line">	return w * h;</span><br><span class="line">&#125;</span><br><span class="line">int CRectangle::Perimeter() &#123;</span><br><span class="line">	return 2 * (w + h);</span><br><span class="line">&#125;</span><br><span class="line">void CRectangle::nit(int w_, int h_) &#123;</span><br><span class="line">	w = w_; h = h_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用<code>::</code>，调用依然是通过：对象/对象的指针/对象的引。</li>
</ol>
<h3 id="类成员的可访问范围"><a href="#类成员的可访问范围" class="headerlink" title="类成员的可访问范围"></a>类成员的可访问范围</h3><p>关键字 —— 类成员可被访问的范围。</p>
<ul>
<li><code>private</code>：指定私有成员，只能在成员函数内被访问。</li>
<li><code>public</code>：指定公有成员，可以在任何地方被访问。</li>
<li><code>protected</code>：指定保护成员。</li>
</ul>
<p>缺省的情况默认为<strong>私有成员</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Man &#123;</span><br><span class="line">	int nAge;// 私有成员</span><br><span class="line">	char szName[20];// 私有成员</span><br><span class="line">	public:</span><br><span class="line">	void SetName(char * Name) &#123;</span><br><span class="line">		strcpy(szName, Name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://imgse.com/i/z02hpF"><img src="https://s1.ax1x.com/2022/12/01/z02hpF.png" alt="z02hpF.png"></a></p>
<ul>
<li>设置私有成员的目的：<br>强制对成员变量的访问一定要通过成员函数进行。</li>
<li>设置私有成员的机制——<strong>隐藏</strong>。</li>
</ul>
<h1 id="Week3-类和对象"><a href="#Week3-类和对象" class="headerlink" title="Week3 类和对象"></a>Week3 类和对象</h1><h2 id="内联成员函数和重载成员函数"><a href="#内联成员函数和重载成员函数" class="headerlink" title="内联成员函数和重载成员函数"></a>内联成员函数和重载成员函数</h2><ul>
<li>inline + 成员函数名</li>
<li>整个函数体写在类定义内部</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::func1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>成员函数可以重载，也可以带缺省参数</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>成员函数的一种</p>
<ul>
<li>名字与类名相同，可以有参数，不能有返回值(void也不行) </li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数</li>
<li>默认构造函数无参数，不做任何操作</li>
</ul>
<p>可以有多个构造函数，参数个数或类型不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i );</span><br><span class="line"><span class="built_in">Complex</span> (<span class="type">double</span> r );</span><br><span class="line"><span class="built_in">Complex</span> (Complex c1, Complex c2);</span><br></pre></td></tr></table></figure>
<p>构造函数最好是public的，private构造函数 不能直接用来初始化对象</p>
<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>只有一个参数，既对同类对象的引用</p>
<ul>
<li><code>X::X( X &amp;)</code></li>
<li><code>X::X(const X &amp;)</code></li>
</ul>
<p>没有定义，编译器会自动生成。如果定义了，默认的就不存在。</p>
<h3 id="使用的三种情况"><a href="#使用的三种情况" class="headerlink" title="使用的三种情况"></a>使用的三种情况</h3><ul>
<li>用一个对象去<strong>初始化</strong>同类的另一个对象（不适用于赋值！）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类A的复制构造函数将被调用。（即形参用构造函数初始化，这时<strong>形参和实参就不一定相等</strong>了！）</li>
<li>如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。（这时<strong>返回值也不一定与返回对象相等</strong>！）</li>
</ul>
<h2 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h2><p>目的：</p>
<ul>
<li>实现类型的自动转换</li>
</ul>
<p>特点：</p>
<ul>
<li>只有一个参数</li>
<li>不是复制构造函数</li>
</ul>
<p>编译系统会自动调用转换构造函数</p>
<ul>
<li>建立一个临时对象/临时变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="type">double</span> real, imag;</span><br><span class="line">  	<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">      	real = r;</span><br><span class="line">      	imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="built_in">Complex</span>(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">      	real = i;</span><br><span class="line">      	imag = <span class="number">0</span>;</span><br><span class="line">      	cout &lt;&lt; <span class="string">&quot;IntConstructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">  	Complex c2 = <span class="number">12</span>; <span class="comment">// 初始化</span></span><br><span class="line">	c1 = <span class="number">9</span>; <span class="comment">// 赋值，9被自动转换成一个临时的Complex对象</span></span><br><span class="line">  	cout &lt;&lt; c1.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c1.imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>成员函数的一种</p>
<ul>
<li>名字与类名相同</li>
<li>在前面加<code>~</code></li>
<li>没有参数和返回值</li>
<li>一个类最多只有一个析构函数</li>
</ul>
<p>对象消亡时自动调用析构函数，在对象消亡前做善后工作，释放动态分配的空间等等</p>
<p>定义类时没写析构函数, 则编译器生成缺省析构函数，但不涉及释放用户申请的内存释放等清理工作</p>
<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员：在说明前面加了<code>static</code>关键字的成员。 </p>
<ul>
<li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 </li>
</ul>
<blockquote>
<p> <code>sizeof</code> 运算符不会计算静态成员变量。 静态成员变量放在所有对象的外部</p>
</blockquote>
<p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用与某个对象。 </p>
<p>因此静态成员<strong>不需要通过对象</strong>就能访问。</p>
<ul>
<li><code>类名::成员名</code>：<code>CRectangle::PrintTotal();</code></li>
<li><code>对象名.成员名</code>：<code>CRectangle r; r.PrintTotal();</code></li>
<li><code>指针-&gt;成员名</code>：<code>CRectangle * p = &amp;r;   p-&gt;PrintTotal();</code></li>
<li><code>引用.成员名</code>：<code>CRectangle &amp; ref = r;  int n = ref.nTotalNumber;</code></li>
</ul>
<p>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在静态成员函数本质上是全局函数，设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。 </p>
<p>注意：</p>
<ul>
<li>静态成员变量需要在类外部特别声明初始化：<code>int CRectangle::nTotalNumber = 0;</code></li>
<li>在静态成员函数中，不能访问非静态成员变量， 也不能调用非静态成员函数。（原因，不知道作用于哪个对象）</li>
</ul>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>成员对象: 一个类的成员变量是另一个类的对象</p>
<p>包含成员对象的类叫封闭类 (Enclosing) </p>
<p>封闭类一定要自己定义构造函数，可以利用初始化列表方便的定义构造函数</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名::构造函数(参数表):成员变量<span class="number">1</span>(参数表), 成员变量<span class="number">2</span>(参数表), … </span><br><span class="line">&#123; </span><br><span class="line">	… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员对象初始化列表中的参数</p>
<ul>
<li>任意复杂的表达式</li>
<li>函数 / 变量/ 表达式中的函数，变量有定义 </li>
</ul>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><p>当封闭类对象生成时：</p>
<ul>
<li><p>S1: 执行所有成员对象的构造函数</p>
</li>
<li><p>S2: 执行封闭类的构造函数</p>
</li>
</ul>
<p>成员对象的构造函数调用顺序：</p>
<ul>
<li>和成员对象在类中的说明顺序一致</li>
<li>与在成员初始化列表中出现的顺序无关</li>
</ul>
<p>当封闭类的对象消亡时：</p>
<ul>
<li>S1: 先执行封闭类的析构函数</li>
<li>S2: 执行成员对象的析构函数</li>
</ul>
<p>析构函数顺序和构造函数的调用顺序相反 </p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>一个类的友元函数可以访问该类的私有成员</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>A是B的友元类 $\rightarrow$ A的成员函数可以访问B的私有成员 </p>
<p>友元类之间的关系不能传递，不能继承</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h2><p>起源：C++程序翻译为C程序示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="type">int</span> price;</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">SetPrice</span><span class="params">(<span class="type">int</span> p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CCar::SetPrice</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	price = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	CCar car;</span><br><span class="line">  	car.<span class="built_in">SetPrice</span>(<span class="number">20000</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	<span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetPrice</span><span class="params">(<span class="keyword">struct</span> CCar *this, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;price = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">CCar</span> <span class="title">car</span>;</span></span><br><span class="line">  	SetPrice(&amp;car, <span class="number">20000</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this</code> 指针的作用：其作用就是指向成员函数所作用的对象，例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">this</span>-&gt;real++;</span><br><span class="line">  	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  	<span class="comment">// 相当于 void Hello(A * this ) &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;</span></span><br><span class="line">  	<span class="comment">// 如果是 void Hello() &#123; cout &lt;&lt; i &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125; 就出错</span></span><br><span class="line">&#125;;      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	A *p = <span class="literal">NULL</span>;</span><br><span class="line">  	p-&gt;<span class="built_in">Hello</span>();</span><br><span class="line">  	<span class="built_in">Hello</span>(p); </span><br><span class="line">&#125; <span class="comment">// 输出：hello</span></span><br></pre></td></tr></table></figure>
<p>静态成员函数中不能使用 this 指针！ 因为静态成员函数并不具体作用与某个对象! 因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数！ </p>
<h2 id="常量对象、常量成员函数、常引用"><a href="#常量对象、常量成员函数、常引用" class="headerlink" title="常量对象、常量成员函数、常引用"></a>常量对象、常量成员函数、常引用</h2><h3 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h3><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在<strong>前面</strong>加 <code>const</code> 关键字。 </p>
<ul>
<li>不能修改常量对象的值</li>
<li>不能调用非常量成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">instance</span>;</span><br></pre></td></tr></table></figure>
<h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>在类的成员函数说明<strong>后面</strong>可以加<code>const</code>关键字，则 该成员函数成为常量成员函数。</p>
<p>常量成员函数执行期间不应修改其所作用的对象 。因此，在常量成员函数中：</p>
<ul>
<li>不能修改成员变量的值 （静态成员变量除外）</li>
<li>也不能调用同类的非常量成员函数（静态成员函数除外）。</li>
</ul>
<p>常量成员函数的重载：两个成员函数，名字和参数表都一样，但是一个 是<code>const</code>，一个不是，算重载。</p>
<h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>引用前面可以加<code>const</code>关键字，成为常引用。 不能通过常引用，修改其引用的变量。</p>
<p>为了减少形参调用复制构造函数的开销，可以使用对象的引用做参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">  	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintObj</span><span class="params">(<span class="type">const</span> Sample &amp;o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/senorl">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E2%80%9D-amp-%E2%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">按位与”&amp;”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96%E2%80%9D-%E2%80%9D"><span class="toc-number">2.2.</span> <span class="toc-text">按位或”|”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E2%80%9D-%E2%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">按位异或”^”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%9D%9E%E2%80%9D-%E2%80%9D"><span class="toc-number">2.4.</span> <span class="toc-text">按位非”~”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9D-lt-lt-%E2%80%9D"><span class="toc-number">2.5.</span> <span class="toc-text">左移运算符”&lt;&lt;”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%9C-gt-gt-%E2%80%9D"><span class="toc-number">2.6.</span> <span class="toc-text">右移运算符 “&gt;&gt;”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">const 用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">内联函数与重载函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数的缺省参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AE%A2%E8%A7%82%E4%BA%8B%E7%89%A9%E6%8A%BD%E8%B1%A1%E5%87%BA%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">6.1.1.</span> <span class="toc-text">从客观事物抽象出类的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">对象的内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">访问类的成员变量和成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%99%E6%B3%95"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">其他写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.2.</span> <span class="toc-text">类成员的可访问范围</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Week3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">Week3 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">内联成员函数和重载成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">复制构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">7.3.1.</span> <span class="toc-text">使用的三种情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">类型转换构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">静态成员变量和静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-number">7.7.</span> <span class="toc-text">成员对象和封闭类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.7.2.</span> <span class="toc-text">调用顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">7.8.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">7.8.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">7.8.2.</span> <span class="toc-text">友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">7.9.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">7.10.</span> <span class="toc-text">常量对象、常量成员函数、常引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.10.1.</span> <span class="toc-text">常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.10.2.</span> <span class="toc-text">常量成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">7.10.3.</span> <span class="toc-text">常引用</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&text=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&is_video=false&description=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=零基础学习c程序（三）—— c++程序设计&body=Check out this article: http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&name=零基础学习c程序（三）—— c++程序设计&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&t=零基础学习c程序（三）—— c++程序设计"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    senor
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/senorl">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
