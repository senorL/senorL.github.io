<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>零基础学习c程序（二） ——c程序设计进阶 | senor</title><meta name="keywords" content="c程序学习"><meta name="author" content="senor"><meta name="copyright" content="senor"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="函数函数的定义与声明以一个求绝对值的过程为例：#include &lt;iostream&gt;using namespace std;int absolute(int n)&amp;#123;    if(n &lt; 0)    return (-n);    else    return n;&amp;#125;int main()&amp;#123;    int m &#x3D; -123, result &#x3D; 0;">
<meta property="og:type" content="article">
<meta property="og:title" content="零基础学习c程序（二） ——c程序设计进阶">
<meta property="og:url" content="http://example.com/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="senor">
<meta property="og:description" content="函数函数的定义与声明以一个求绝对值的过程为例：#include &lt;iostream&gt;using namespace std;int absolute(int n)&amp;#123;    if(n &lt; 0)    return (-n);    else    return n;&amp;#125;int main()&amp;#123;    int m &#x3D; -123, result &#x3D; 0;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/default_top_img.png">
<meta property="article:published_time" content="2022-10-25T12:37:41.000Z">
<meta property="article:modified_time" content="2023-07-16T03:01:05.160Z">
<meta property="article:author" content="senor">
<meta property="article:tag" content="c程序学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default_top_img.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://example.com/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '零基础学习c程序（二） ——c程序设计进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-16 11:01:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/toumingdu.css"><link rel="stylesheet" href="/css/iconfont.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">senor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">零基础学习c程序（二） ——c程序设计进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-25T12:37:41.000Z" title="发表于 2022-10-25 20:37:41">2022-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-16T03:01:05.160Z" title="更新于 2023-07-16 11:01:05">2023-07-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/" data-flag-title="零基础学习c程序（二） ——c程序设计进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义与声明"><a href="#函数的定义与声明" class="headerlink" title="函数的定义与声明"></a>函数的定义与声明</h2><p>以一个求绝对值的过程为例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int absolute(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">    return (-n);</span><br><span class="line">    else</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m = -123, result = 0;</span><br><span class="line">    result = absolute(m);</span><br><span class="line">    cout &lt;&lt; result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>(int n)</code>为形式参数（形参），即形式上的参数，并非真正让函数执行传给参数，只是用来辅助函数定义。<code>m</code>为实际参数（实参），是实际运行时传入的参数。<br>函数需要有函数类型（返回类型），函数名称，参数，函数主体。<br>函数的调运方式可以分为下面三种：  </p>
<ol>
<li>函数调用<strong>作为独立语句</strong>，例如：  <pre><code>  `stringprint()`  
</code></pre></li>
<li>函数<strong>作为表达式的一部分</strong>，例如：  <pre><code> `number = max(numA,numB)/2;`  
</code></pre></li>
<li>以<strong>实参形式出现在其他函数的调用中</strong>，例如：  <pre><code> `number = min(sum(-5,100),numC);`
</code></pre></li>
</ol>
<p>函数可以没有输入参数和返回值  </p>
<p><strong>函数是c程序的基本构成单位</strong>    </p>
<ul>
<li>一个c程序有一个或多个源程序文件组成。</li>
<li>一个源程序文件可以由一个或多个函数组成。<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xffZ26"><img src="https://s1.ax1x.com/2022/10/27/xffZ26.png" alt="xffZ26.png"></a><br>将两个文件放进同一个目录之下，在主函数的头文件中输入<code>#include &quot;max.h&quot;</code>就可以连接两个文件。注意的是<code>&lt;&gt;</code>默认先搜索系统函数库，<code>&quot;&quot;</code>优先搜索当前目录。 </li>
</ul>
<p><strong>函数都是有”类型”的</strong>    </p>
<ul>
<li>函数的类型是指<strong>函数返回值的数据类型</strong>   <h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2>可以将函数定义在main函数后面，但需要声明该函数<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xffhdJ"><img src="https://s1.ax1x.com/2022/10/27/xffhdJ.png" alt="xffhdJ.png"></a><br>函数的原型 = 返回值类型 + 函数名 + 参数类型<br>总结：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xfhDmD"><img src="https://s1.ax1x.com/2022/10/27/xfhDmD.png" alt="xfhDmD.png"></a><h2 id="函数的执行"><a href="#函数的执行" class="headerlink" title="函数的执行"></a>函数的执行</h2>main函数是程序执行的入口点，过程中如果遇到了新的函数调用的语句，main函数被打断，执行这个新的函数调用的语句，之后main函数再向下执行（绿色为内存空间）<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xhV8DP"><img src="https://s1.ax1x.com/2022/10/27/xhV8DP.png" alt="xhV8DP.png"></a><br>被打断时，main函数会1。初始化新的函数，2.传递参数，3.保存当前现场，之后接1.收函数的返回值，2.恢复现场，从断点处继续执行<br>调用结束后，这部分内存空间会被释放掉<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xhVljI"><img src="https://s1.ax1x.com/2022/10/27/xhVljI.png" alt="xhVljI.png"></a><h3 id="函数参数的传递"><a href="#函数参数的传递" class="headerlink" title="函数参数的传递"></a>函数参数的传递</h3>是复制参数，对原参数没有影响<br><strong>copy!!!!</strong><br><a target="_blank" rel="noopener" href="https://imgse.com/i/xhV3ut"><img src="https://s1.ax1x.com/2022/10/27/xhV3ut.png" alt="xhV3ut.png"></a><h2 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h2></li>
</ul>
<ol>
<li>局部变量<br>在函数内或块内定义，只在这个函数或块内起作用的变量。</li>
<li>全局变量<br>在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xhZOoT"><img src="https://s1.ax1x.com/2022/10/27/xhZOoT.png" alt="xhZOoT.png"></a><br>当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量</p>
<h2 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h2><h3 id="数组元素做函数参数"><a href="#数组元素做函数参数" class="headerlink" title="数组元素做函数参数"></a>数组元素做函数参数</h3><p>与正常情况相同</p>
<h3 id="数组名做函数参数"><a href="#数组名做函数参数" class="headerlink" title="数组名做函数参数"></a>数组名做函数参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void change(int a[])</span><br><span class="line">&#123;</span><br><span class="line">    a[0] = 30;</span><br><span class="line">    a[1] = 50;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[2] = &#123;3, 5&#125;;</span><br><span class="line">    change(a)</span><br><span class="line">    cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终端输出结果为 30 50<br>传递时仍然是copy参数，注意数组名a不是变量，是常量，代表数组在内存中的地址<br>相当于把数组在内存中的地址传入了函数<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xheg1J"><img src="https://s1.ax1x.com/2022/10/27/xheg1J.png" alt="xheg1J.png"></a></p>
<h2 id="函数应用示例"><a href="#函数应用示例" class="headerlink" title="函数应用示例"></a>函数应用示例</h2><p><a target="_blank" rel="noopener" href="https://imgse.com/i/xhnFPO"><img src="https://s1.ax1x.com/2022/10/27/xhnFPO.png" alt="xhnFPO.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/xhnCa6"><img src="https://s1.ax1x.com/2022/10/27/xhnCa6.png" alt="xhnCa6.png"></a><br>需要计算的信息 年，月，日，星期<br>其中星期不受其他因素影响<br>思路：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/xhnPIK"><img src="https://s1.ax1x.com/2022/10/27/xhnPIK.png" alt="xhnPIK.png"></a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int days;</span><br><span class="line">int get_dayofweek();</span><br><span class="line">int get_year();</span><br><span class="line">int get_month(int);</span><br><span class="line">int main() &#123;</span><br><span class="line">    int year, month, dayofweek;</span><br><span class="line">    int leap_year;</span><br><span class="line">    char week[7][10] = &#123;&quot;Saturday&quot;,&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;&#125;;</span><br><span class="line">    while((cin &gt;&gt; days) &amp;&amp; days != -1) &#123;</span><br><span class="line">        dayofweek = get_dayofweek();</span><br><span class="line">        year = get_year();</span><br><span class="line">        leap_year = (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0);</span><br><span class="line">        month = get_month(leap_year);</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; &quot;-&quot; &lt;&lt; month &lt;&lt; &quot;-&quot; &lt;&lt; ++days &lt;&lt; &quot; &quot; &lt;&lt; week[dayofweek];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 计算星期几</span><br><span class="line">int get_dayofweek() &#123;</span><br><span class="line">    int dayofweek;</span><br><span class="line">    dayofweek = days % 7;</span><br><span class="line">    return dayofweek;</span><br><span class="line">&#125;</span><br><span class="line">// 计算年数</span><br><span class="line">int get_year() &#123;</span><br><span class="line">    int i = 2000, leap_year;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        leap_year = (i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0);</span><br><span class="line">        if(leap_year == 1 &amp;&amp; days &gt;= 366) &#123;</span><br><span class="line">            days = days - 366;</span><br><span class="line">            i++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(leap_year == 0 &amp;&amp; days &gt;= 365) &#123;</span><br><span class="line">            days = days - 365;</span><br><span class="line">            i++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">// 计算月份</span><br><span class="line">int get_month(int leap_year) &#123;</span><br><span class="line">    int pmonth[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;</span><br><span class="line">    int rmonth[12] = &#123;31, 29, 31, 30, 31, 30, 31, 31, 30 ,31, 30, 31&#125;;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        if(leap_year == 1 &amp;&amp; days &gt;= rmonth[j]) &#123;</span><br><span class="line">            days = days - rmonth[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(leap_year == 0 &amp;&amp; days &gt;= pmonth[j]) &#123;</span><br><span class="line">            days = days - rmonth[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else break;</span><br><span class="line">        &#125;</span><br><span class="line">        return ++j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>全局变量</strong></p>
<ul>
<li>破坏了函数的“相对独立性”</li>
<li>增加了函数之间的“耦合性”</li>
<li>函数之间的交互不够清晰</li>
<li>不在非常必要的情况下，不要使用全局变量</li>
</ul>
<h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><ul>
<li><strong>函数不能嵌套定义</strong><ul>
<li>所有函数一律平等</li>
</ul>
</li>
<li><strong>函数可以嵌套调用</strong><ul>
<li>无论嵌套多少层，原理都一样  </li>
<li><strong>函数可以调用自己吗？</strong></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xofHbV"><img src="https://s1.ax1x.com/2022/10/31/xofHbV.png" alt="xofHbV.png"></a><br>上面这种方式就称为“递归调用”<br>一个函数在其定义中直接或间接调用自身的一种方法。<br><strong>递归调用与普通调用没有区别！！！</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xohXeP"><img src="https://s1.ax1x.com/2022/10/31/xohXeP.png" alt="xohXeP.png"></a></p>
<h3 id="深入理解递归的过程"><a href="#深入理解递归的过程" class="headerlink" title="深入理解递归的过程"></a>深入理解递归的过程</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/xo4jXR"><img src="https://s1.ax1x.com/2022/10/31/xo4jXR.png" alt="xo4jXR.png"></a></p>
<h3 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h3><ol>
<li>切饼</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xo5eBt"><img src="https://s1.ax1x.com/2022/10/31/xo5eBt.png" alt="xo5eBt.png"></a></p>
<ul>
<li>q(n) = q(n - 1) + n;</li>
<li>q(0) = 1;</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xojcN9"><img src="https://s1.ax1x.com/2022/10/31/xojcN9.png" alt="xojcN9.png"></a></p>
<p><strong>递归与递推</strong></p>
<ul>
<li><strong>不同</strong><ul>
<li>递推的关注点放在<em>起始点</em></li>
<li>递归的关注点放在<em>求解目标</em></li>
</ul>
</li>
<li><strong>相同</strong><ul>
<li>重点在表现<em>第<code>i</code>次</em>与<em>第<code>i+1</code>次</em>的关系  </li>
</ul>
</li>
</ul>
<p><strong>用递归实现递推</strong></p>
<ul>
<li><strong>优点</strong><ul>
<li>让程序变得简明</li>
</ul>
</li>
<li><strong>方法</strong><ul>
<li>把关注点放到要求解的目标上</li>
<li>找到第<code>n</code>次做与第<code>n-1</code>次做之间的关系</li>
<li>确定第<code>1</code>次的返回结果  </li>
</ul>
</li>
</ul>
<ol>
<li>斐波那契数列</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xovP4s"><img src="https://s1.ax1x.com/2022/10/31/xovP4s.png" alt="xovP4s.png"></a></p>
<ol>
<li>进制转换</li>
</ol>
<p>余数需要反向输出，因此<code>cout</code>在调用<code>convert</code>函数之后</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xovvGR"><img src="https://s1.ax1x.com/2022/10/31/xovvGR.png" alt="xovvGR.png"></a></p>
<ol>
<li>汉诺塔问题<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7soxx"><img src="https://s1.ax1x.com/2022/11/01/x7soxx.png" alt="x7soxx.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7s5GR"><img src="https://s1.ax1x.com/2022/11/01/x7s5GR.png" alt="x7s5GR.png"></a></li>
</ol>
<ul>
<li>当只有一个盘子时，仅需<code>a -- c</code>   </li>
<li>当有两个盘子时，需要如图<code>123</code>步   </li>
<li>当有三个以上的盘子时，都可以理解成最下面的盘子和上面一个（堆）盘子的情况，因此依然是如图的<code>123</code>步<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7sIR1"><img src="https://s1.ax1x.com/2022/11/01/x7sIR1.png" alt="x7sIR1.png"></a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void move(int m, char x, char y, char z)</span><br><span class="line">&#123;</span><br><span class="line">    if(m == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;把一个盘子从&quot; &lt;&lt; x &lt;&lt; &quot;移动到&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        move(m - 1, x, z, y);</span><br><span class="line">        cout &lt;&lt; &quot;把一个盘子从&quot; &lt;&lt; x &lt;&lt; &quot;移动到&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">        move(m - 1, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cout &lt;&lt; &quot;请输入盘数n =&quot;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; &quot;在3根柱子上移动&quot; &lt;&lt; n &lt;&lt; &quot;只盘的步骤为：&quot; &lt;&lt; endl;</span><br><span class="line">    move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟连续发生的动作"><a href="#模拟连续发生的动作" class="headerlink" title="模拟连续发生的动作"></a>模拟连续发生的动作</h2><ul>
<li><strong>方法</strong><ul>
<li>搞清楚连续发生的动作是什么（定义函数）<br> <code>void move(int m, char x, char y, char z)</code></li>
<li>搞清楚不同次动作之间的关系（描述递归函数之间关系）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move(m - 1, x, z, y);</span><br><span class="line">cout &lt;&lt; &quot;把一个盘子从&quot; &lt;&lt; x &lt;&lt; &quot;移动到&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">move(m - 1, y, x, z);</span><br></pre></td></tr></table></figure></li>
<li>搞清楚边界条件是什么（描述边界条件）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> if(m == 1)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;把一个盘子从&quot; &lt;&lt; x &lt;&lt; &quot;移动到&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol>
<li>放苹果<br>题目：把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？<br>注意：5，1，1和1，5，1是同一种分法<br>输入：7 3<br>输出： 8<br>先设定有一个函数<code>f(m, n)</code>能解决这个问题，分为两种情况，如果盘子数大于苹果数，那么<code>f(m,n) = f(m, m)</code>,因为多余的盘子是可以删去的<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7ySzt"><img src="https://s1.ax1x.com/2022/11/01/x7ySzt.png" alt="x7ySzt.png"></a><br>如果苹果数大于等于盘子数，那么再次分为有盘子空着和没盘子空着，如果是有盘子空着的情况，那假设每次都至少有一个盘子空着，那么删除这个盘子对结果没有影响，即<code>f(m, n) = f(m, n - 1)</code>,如果是没盘子空着的情况，那减去每个盘子上至少放的苹果，对最后结果没有影响，即<code>f(m , n) = f(m - n, n)</code>，之后的过程将重复这些可能继续下去<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x72lcR"><img src="https://s1.ax1x.com/2022/11/01/x72lcR.png" alt="x72lcR.png"></a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int count(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(m &lt;= 0 || n &lt;= 1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(m &lt; n)</span><br><span class="line">        return count(m , m);</span><br><span class="line">    else</span><br><span class="line">        return count(m, n - 1) + count(m - n, n);</span><br><span class="line">&#125;</span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">    int apples, plates;</span><br><span class="line">    cin &gt;&gt; apples &gt;&gt; plates;</span><br><span class="line">    cout &lt;&lt; count(apples, plates);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>逆波兰表达式<br>每遇到一个运算符就是一个独立的逆波兰表达式的开始<br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7yUQx"><img src="https://s1.ax1x.com/2022/11/01/x7yUQx.png" alt="x7yUQx.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7ydOK"><img src="https://s1.ax1x.com/2022/11/01/x7ydOK.png" alt="x7ydOK.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/x7yay6"><img src="https://s1.ax1x.com/2022/11/01/x7yay6.png" alt="x7yay6.png"></a></li>
</ol>
<h3 id="利用递归进行“自动分析”"><a href="#利用递归进行“自动分析”" class="headerlink" title="利用递归进行“自动分析”"></a>利用递归进行“自动分析”</h3><ul>
<li><strong>方法</strong><ul>
<li>先假设 存在一个函数能给出答案</li>
<li>在利用这个函数的前提下，分析如何解决问题</li>
<li>搞清楚最简单的情况下答案是什么</li>
</ul>
</li>
</ul>
<h2 id="习题课一-：枚举、模拟与递归"><a href="#习题课一-：枚举、模拟与递归" class="headerlink" title="习题课一 ：枚举、模拟与递归"></a>习题课一 ：枚举、模拟与递归</h2><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><p>变量的三要素：变量的地址、变量的值、变量名字<br>变量的地址称为“指向该变量的指针”<br>可以用<strong>取地址运算符<code>&amp;</code></strong> 来得到一个变量的地址<br><code>cout &lt;&lt; &amp;c &lt;&lt; endl</code> 获取变量<code>c</code>的地址<br>可以用<strong>指针运算符<code>*</code></strong> 实现操作变量<br><code>cout &lt;&lt; *&amp;c &lt;&lt; endl = cout &lt;&lt; c &lt;&lt; endl</code></p>
<h2 id="什么是指针变量"><a href="#什么是指针变量" class="headerlink" title="什么是指针变量"></a>什么是指针变量</h2><p>专门用于存放指针（某个变量的地址）的变量  </p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zClGY4"><img src="https://s1.ax1x.com/2022/11/11/zClGY4.png" alt="zClGY4.png"></a></p>
<p><code>pointer</code> 就是一个指针变量，值为<code>c</code>的地址，称为<em>指向变量<code>c</code>的“指针变量”</em>，且指针变量<code>pointer</code>也有自己的地址。</p>
<h2 id="定义一个指针变量"><a href="#定义一个指针变量" class="headerlink" title="定义一个指针变量"></a>定义一个指针变量</h2><p><code>int * pointer</code> <code>int</code> 是指针变量的<strong>基类型</strong><br><code>*</code>是指针运算符，<code>pointer</code>的类型<br><code>pointer</code> 是指针变量的名字<br>基类型 ：指针变量<strong>指向的</strong>变量的类型<br>指针变量的定义<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int c = 76;</span><br><span class="line">int * pointer;</span><br><span class="line">pointer = &amp;c;</span><br></pre></td></tr></table></figure><br>赋值后，称指针变量<code>pointer</code>指向了变量<code>c</code><br><code>pointer</code>只能用来存放地址<br><code>*pointer</code> 为 <code>pointer</code>所<strong>指向的存储单元的内容</strong>是<strong>变量<code>c</code></strong><br><code>NULL</code>空指针，通常用<code>int *p1 = NULL</code>赋予初始值</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/zCHkHH"><img src="https://s1.ax1x.com/2022/11/11/zCHkHH.png" alt="zCHkHH.png"></a></p>
<ul>
<li><code>&amp;*pointer = &amp;(*pointer)</code>  </li>
<li><code>*&amp;a = *(&amp;a)</code></li>
<li><code>(*pointer)++</code> 不等于 <code>*pointer++</code></li>
</ul>
<h3 id="指针变量的"><a href="#指针变量的" class="headerlink" title="指针变量的++--"></a>指针变量的<code>++--</code></h3><p><code>pointer++</code>的含义<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int * p2 = NULL;</span><br><span class="line">p2 = &amp;a;</span><br><span class="line">p2++;</span><br></pre></td></tr></table></figure><br>此时<code>p2++</code>指向地址<code>0x0012FF7A</code> ，原因是基类型为<code>int</code>型，所以将跨过四个字节，因此也说明基类型的重要性</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zC3JMR"><img src="https://s1.ax1x.com/2022/11/11/zC3JMR.png" alt="zC3JMR.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zC8u6A"><img src="https://s1.ax1x.com/2022/11/11/zC8u6A.png" alt="zC8u6A.png"></a></p>
<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><p>数组的地址<br>数组名代表数组首元素的地址<br>数组名相当于指向数组第一个元素的指针<br><code>*a = a[0]</code></p>
<h3 id="用指针访问数组"><a href="#用指针访问数组" class="headerlink" title="用指针访问数组"></a>用指针访问数组</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/zCHlDg"><img src="https://s1.ax1x.com/2022/11/11/zCHlDg.png" alt="zCHlDg.png"></a></p>
<p><strong>注意</strong>   </p>
<ul>
<li><code>int * p = &amp;a[0]</code> </li>
<li><code>a++</code> 没有意义，但是<code>p++</code>会引起<code>p</code>变化</li>
<li><code>p</code>可以指向数组最后一个元素以后的元素  </li>
</ul>
<p><strong>指针做加减运算一定注意有效的范围</strong></p>
<p>例子 ：倒置数组元素<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[10], *p = NULL, *q = NULL,temp;</span><br><span class="line">    for(p = a; p &lt; a + 10; p++)</span><br><span class="line">    cin &gt;&gt; *p;</span><br><span class="line">    for(p = a, q = a + 9; p &lt; q; p++, q--) &#123;</span><br><span class="line">        temp = *p; *p = *q; *q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    for(p = a; p &lt; a + 10; p++)</span><br><span class="line">    cout &lt;&lt; setw(3) &lt;&lt; *p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串与指针"><a href="#字符串与指针" class="headerlink" title="字符串与指针"></a>字符串与指针</h2><p>指向数组的指针<br><code>int a[10]; int *p; p = a;</code><br>指向字符串的指针<br><code>char a[10]; char *p; p = a;</code>  </p>
<p>注意，在打印字符数组时<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char a[3] = &#123;&#x27;h&#x27;,&#x27;i&#x27;,&#x27;\0&#x27;&#125;;</span><br><span class="line">char *p = a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>输出结果都会是<code>hi</code>,如果想输出字符串的地址应该使用<code>cout &lt;&lt; static_cast&lt;void*&gt; (c) &lt;&lt; endl</code>  </p>
<p>字符串指针举例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头文件</span><br><span class="line">int main() &#123;</span><br><span class="line">    char buffer[10] = &quot;ABC&quot;;</span><br><span class="line">    char *pc;</span><br><span class="line">    pc = &quot;hello&quot;;</span><br><span class="line">    cout &lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">    pc++;</span><br><span class="line">    cout &lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *pc &lt;&lt; endl;</span><br><span class="line">    pc = buffer;</span><br><span class="line">    cout &lt;&lt; pc ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">ello</span><br><span class="line">e</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure></p>
<h2 id="再谈一维数组的地址"><a href="#再谈一维数组的地址" class="headerlink" title="再谈一维数组的地址"></a>再谈一维数组的地址</h2><p><code>a</code>相当于指向数组首元素地址的指针<br><code>&amp;a</code>相当于整个数组的指针<br><code>*(&amp;a)</code>相当于<code>a</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/zCoVNq"><img src="https://s1.ax1x.com/2022/11/11/zCoVNq.png" alt="zCoVNq.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zCo8ER"><img src="https://s1.ax1x.com/2022/11/11/zCo8ER.png" alt="zCo8ER.png"></a></p>
<p><strong><code>&amp;a</code>相当于管辖范围上升一级</strong><br><strong><code>*a</code>相当于管辖范围下降一级</strong></p>
<h2 id="指向二维数组的指针"><a href="#指向二维数组的指针" class="headerlink" title="指向二维数组的指针"></a>指向二维数组的指针</h2><p>二维数组a[3][4]包含三个元素：a[0],a[1],a[2]<br>每一个元素都是一个包含四个整形元素的数组<br>也就是说，二维数组第一个元素a[0]是个包含四个整形元素的一维数组<br>a[0]是数组元素a[0][0]的指针<br><a target="_blank" rel="noopener" href="https://imgse.com/i/ziYRnH"><img src="https://s1.ax1x.com/2022/11/12/ziYRnH.png" alt="ziYRnH.png"></a><br>规律</p>
<ul>
<li>数组名相当于指向数组第一个元素的指针</li>
<li><code>&amp;E</code>相当于<code>E</code>管辖范围上升一级</li>
<li><code>*E</code>相当于<code>E</code>管辖范围下降一级</li>
</ul>
<h2 id="指针的例子"><a href="#指针的例子" class="headerlink" title="指针的例子"></a>指针的例子</h2><ol>
<li>遍历二维数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头文件</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;;</span><br><span class="line">    int *p;</span><br><span class="line">    for(p = &amp;a[0][0]; p &lt; &amp;a[0][0] + 12; p++) &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>利用指针变量引用多维数组中的数组<br>变量定义语句<code>int (*p)[4]</code>，意思是指向”包含<code>4</code>个<code>int</code>型元素的一维数组”的指针变量<br><a target="_blank" rel="noopener" href="https://imgse.com/i/ziYccD"><img src="https://s1.ax1x.com/2022/11/12/ziYccD.png" alt="ziYccD.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/ziYgje"><img src="https://s1.ax1x.com/2022/11/12/ziYgje.png" alt="ziYgje.png"></a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[3][4] = &#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;;</span><br><span class="line">    int (*p)[4], i, j;</span><br><span class="line">    p = a;</span><br><span class="line">    cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">    cout &lt;&lt; setw(4) &lt;&lt; p[i][j];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><h3 id="指针用作函数参数"><a href="#指针用作函数参数" class="headerlink" title="指针用作函数参数"></a>指针用作函数参数</h3><p>可以将<strong>数组名</strong>作为实参赋给<strong>指针型形参</strong> 。<br>如果想把多维数组名做函数参数<strong>可以在函数定义中</strong>使用<code>int(*p)[数字]</code>或者<code>int p[][数字]</code>的方式。<br>“数组名”可以做形参，因为c++编译器将<strong>形参数组名</strong>作为<strong>指针变量</strong>来处理。  </p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int sum(int array[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 10 - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(array + 1) = *array + *(array + 1);</span><br><span class="line">        array++;</span><br><span class="line">    &#125;</span><br><span class="line">    return *array;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</span><br><span class="line">    cout &lt;&lt; sum(a, 10);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现问题：会修改到数组的值<br>如何”限制”指针实参的功能 ?  </p>
<h3 id="指向符号常量的指针"><a href="#指向符号常量的指针" class="headerlink" title="指向符号常量的指针"></a>指向符号常量的指针</h3><p>符号常量声明语句：</p>
<ul>
<li>方式一：<code>const</code> 数据类型 常量名 = 常量值</li>
<li>方式二：数据类型 <code>const</code> 常量名 = 常量值</li>
</ul>
<p>指向符号常量的指针，定义语句:<code>const int * p</code></p>
<p>关于<strong>指向符号常量的指针</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int a = 78; </span><br><span class="line">    const int b = 28;</span><br><span class="line">    int c = 18;</span><br><span class="line">    const int * pi = &amp;a;</span><br><span class="line">    *pi = 58;   // (error ,*p不能被赋值)</span><br><span class="line">    pi = &amp;b;    // (可以给pi重新赋值)</span><br><span class="line">    *pi = 68;   // (error ,*p不能被赋值)</span><br><span class="line">    pi = &amp;c;    // (可以给pi重新赋值)</span><br><span class="line">    *pi = 88;    // (error ,*p不能被赋值)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指针用作函数返回值"><a href="#指针用作函数返回值" class="headerlink" title="指针用作函数返回值"></a>指针用作函数返回值</h3><p>返回整型数据的函数: <code>int max(int x, int y)</code><br>返回指针类型数据的函数: <code>int *function(int x, int y)</code></p>
<ul>
<li>函数名字前面表示函数的类型 <code>*</code>  </li>
</ul>
<p>需要注意的问题<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int * getInt1()</span><br><span class="line">&#123;</span><br><span class="line">    int value = 20;</span><br><span class="line">    return &amp;value;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int * p;</span><br><span class="line">    p = getInt1();</span><br><span class="line">    cout &lt;&lt; * p &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zANtUJ"><img src="https://s1.ax1x.com/2022/11/14/zANtUJ.png" alt="zANtUJ.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zANYE4"><img src="https://s1.ax1x.com/2022/11/14/zANYE4.png" alt="zANYE4.png"></a></p>
<p>以上程序中，<code>p</code>会指向<code>value</code>，但是根据调用函数的过程且<code>value</code>是一个局部变量，调用结束后这部分内存空间将被释放掉，因此如果这部分空间没有被占用，那么结果仍然是<code>20</code>，但如果被占用，将是个无法预测的结果(在我的vs code上是会直接报错的)。</p>
<p><strong>确保返回地址的意义</strong><br>返回一个处于生命周期中的变量的地址</p>
<ul>
<li>返回全局变量的地址，而非局部变量的地址<br>因此可以选择定义一个全局变量来解决</li>
<li>返回静态局部变量的地址，而非动态局部变量的地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int value = 20;</span><br><span class="line">int * getInt1()</span><br><span class="line">&#123;</span><br><span class="line">    return &amp;value;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int * p;</span><br><span class="line">    p = getInt1();</span><br><span class="line">    cout &lt;&lt; * p &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><p>函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储空间不释放，下一次函数调用时，仍然可以继续使用该变量<br>定义方式: <code>static</code>来进行声明，<code>static int value = 20</code><br>下面的程序中<code>a</code>为动态局部变量,<code>b</code>为静态局部变量<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void function()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    static int b = 0;</span><br><span class="line">    a = a + 1;</span><br><span class="line">    b = b + 1;</span><br><span class="line">    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        function();</span><br><span class="line">        cout &lt;&lt; &quot;Call Again&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后输出结果中，<code>a</code>将一直都为<code>1</code>，因为每调用一次<code>a</code>，最后<code>a</code>所占用的内存空间都会被释放掉，但是<code>b</code>将会一直保存，因此<code>b=5</code>。<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zANd81"><img src="https://s1.ax1x.com/2022/11/14/zANd81.md.png" alt="zANd81.md.png"></a></p>
<p><strong>小结</strong>  </p>
<p>指针用作函数参数</p>
<ul>
<li>函数拿到地址可对其所指内容进行修改</li>
<li>可以使用<code>const</code>来”限制”指针的功能</li>
</ul>
<p>指针用作函数返回值</p>
<ul>
<li>必须确保函数返回的地址是有意义的</li>
<li>返回全局变量或静态局部变量</li>
</ul>
<h1 id="结构体与链表"><a href="#结构体与链表" class="headerlink" title="结构体与链表"></a>结构体与链表</h1><h2 id="什么是结构体"><a href="#什么是结构体" class="headerlink" title="什么是结构体"></a>什么是结构体</h2><p>目的：把一组描述同一个事物的变量捆绑起来<br>构造一个新的数据类型（组合数据类型）—— 结构体<br>定义结构体变量的方式</p>
<ol>
<li>直接用已声明的结构体类型定义变量名<br><code>student student1,student2</code> (结构体类型名) （结构体变量名）<br>前面的<code>student</code>等于<code>int / float</code></li>
<li>在声明类型的同时定义变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line"> char name[50];</span><br><span class="line"> int age;</span><br><span class="line"> float salary;</span><br><span class="line">&#125;li1;</span><br></pre></td></tr></table></figure>
注意大括号后面的;<br>初始化方法，存储方式与多维数组非常接近,使用点（.）运算符可以访问结构变量的成员<br>toupper 将小写字母转换为大写字母<br>例如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">    int id_num;</span><br><span class="line">    char name[10];</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    student mike = &#123;123, &#123;&#x27;m&#x27;,&#x27;i&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;\0&#x27;&#125;&#125;;</span><br><span class="line">    mike.id_num = 20130000 + mike.id_num;</span><br><span class="line">    for(int i = 0; mike.name[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">    mike.name[i] = toupper(mike.name[i]);</span><br><span class="line">    cout &lt;&lt; mike.id_num &lt;&lt; &quot; &quot; &lt;&lt; mike.name &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体变量与函数"><a href="#结构体变量与函数" class="headerlink" title="结构体变量与函数"></a>结构体变量与函数</h2>结构体变量可以直接赋值，相当于copy一份给对方<br>结构体做参数相当于copy一份给函数<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAa00O"><img src="https://s1.ax1x.com/2022/11/14/zAa00O.png" alt="zAa00O.png"></a><br>结构体做返回值相当于copy一份给调用者<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAaB7D"><img src="https://s1.ax1x.com/2022/11/14/zAaB7D.png" alt="zAaB7D.png"></a></li>
</ol>
<h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><p>与普通变量的引用方法相同<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAwli4"><img src="https://s1.ax1x.com/2022/11/14/zAwli4.png" alt="zAwli4.png"></a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">    int id_num;</span><br><span class="line">    char name[10];</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    student mike = &#123;123, &#123;&#x27;m&#x27;,&#x27;i&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;\0&#x27;&#125;&#125;;</span><br><span class="line">    student *one = &amp; mike;</span><br><span class="line">    cout &lt;&lt; (*one).id_num &lt;&lt; &quot; &quot; &lt;&lt; (*one).name;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是123 mike<br>也可以把<code>cout &lt;&lt; (*one).id_num &lt;&lt; &quot; &quot; &lt;&lt; (*one).name;</code>换成<code>cout &lt;&lt; one -&gt; id_num &lt;&lt; &quot; &quot; &lt;&lt; one -&gt; name;</code><br>-&gt; 是指向运算符</p>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><ul>
<li>数组名相当于指向数组第一个元素的指针</li>
<li>指向元素的指针<code>++</code>，则跨过一整个结构体<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAw3W9"><img src="https://s1.ax1x.com/2022/11/14/zAw3W9.png" alt="zAw3W9.png"></a></li>
</ul>
<p><strong>结构体数据类型的特性与普通数据类型的特性是一致的</strong><br>结构体的使用例子<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAw8zR"><img src="https://s1.ax1x.com/2022/11/14/zAw8zR.png" alt="zAw8zR.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zAwMoF"><img src="https://s1.ax1x.com/2022/11/14/zAwMoF.png" alt="zAwMoF.png"></a><br>定义一个结构体数组  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">    char ID[10];</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125; stu[100];</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k, n, flag, count[100] = &#123;0&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    cin &gt;&gt; stu[i].ID &gt;&gt; stu[i].month &gt;&gt; stu[i].day;</span><br><span class="line">    for(int m = 1; m &lt;= 12; m++)</span><br><span class="line">    for(int  d = 1; d &lt;= 31; d++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 0; j = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        if(stu[i].month == m &amp;&amp; stu[i].day == d)</span><br><span class="line">        &#123;</span><br><span class="line">            count[++j] = i; flag++;</span><br><span class="line">        &#125; // count[j]用于记录生日相同学生的学号</span><br><span class="line">        if(flag &gt; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; &quot; &quot;;</span><br><span class="line">            for(k = 1; k &lt;= j; k++)</span><br><span class="line">            cout &lt;&lt; stu[count[k]].ID &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>非常常用的数据结构   </p>
<ul>
<li>链表头：指向第一个链表结点的指针</li>
<li>链表结点：链表中的每一个元素，包括：<ul>
<li>当前结点的数据</li>
<li>下一个结点的地址</li>
</ul>
</li>
<li>链表尾：不再指向其他结点的结点，其地址部分放一个<code>NULL</code>,表示链表到此结束  </li>
</ul>
<h3 id="链表可以动态地创建"><a href="#链表可以动态地创建" class="headerlink" title="链表可以动态地创建"></a>链表可以动态地创建</h3><ol>
<li>动态地申请内存空间<ul>
<li><code>int *pint = new int(1024)  delete pint</code></li>
<li><code>int *pia = new int[4]      delete [] pia</code>  </li>
</ul>
</li>
<li>动态地建立链表节点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">     int id;</span><br><span class="line">     student *next;</span><br><span class="line">&#125;;</span><br><span class="line">student *head;</span><br><span class="line">head = new student;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="逐步建立链表"><a href="#逐步建立链表" class="headerlink" title="逐步建立链表"></a>逐步建立链表</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/zA0aXq"><img src="https://s1.ax1x.com/2022/11/14/zA0aXq.png" alt="zA0aXq.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zA0wn0"><img src="https://s1.ax1x.com/2022/11/14/zA0wn0.png" alt="zA0wn0.png"></a></p>
<h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><ol>
<li><p>删除结点<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zA0Xut"><img src="https://s1.ax1x.com/2022/11/14/zA0Xut.png" alt="zA0Xut.png"></a></p>
</li>
<li><p>插入结点<br><a target="_blank" rel="noopener" href="https://imgse.com/i/zA0LjI"><img src="https://s1.ax1x.com/2022/11/14/zA0LjI.png" alt="zA0LjI.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/zA0qgA"><img src="https://s1.ax1x.com/2022/11/14/zA0qgA.png" alt="zA0qgA.png"></a></p>
</li>
</ol>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">senor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/">http://example.com/2022/10/25/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E2%80%94%E2%80%94c%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">senor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/">c程序学习</a></div><div class="post_share"><div class="social-share" data-image="/img/default_top_img.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src="/img/default_top_img.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">零基础学习c程序（三）—— c++程序设计</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0C%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="next-cover" src="/img/default_top_img.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">零基础学习C程序（一）——计算概论与程序设计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/15/week4/" title="week4"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">week4</div></div></a></div><div><a href="/2023/02/12/week5/" title="week5"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">week5</div></div></a></div><div><a href="/2023/03/09/week7/" title="week7"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">week7</div></div></a></div><div><a href="/2023/02/28/week6/" title="week"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">week</div></div></a></div><div><a href="/2022/09/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0C%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/" title="零基础学习C程序（一）——计算概论与程序设计"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">零基础学习C程序（一）——计算概论与程序设计</div></div></a></div><div><a href="/2022/11/22/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0c%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="零基础学习c程序（三）—— c++程序设计"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">零基础学习c程序（三）—— c++程序设计</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">senor</div><div class="author-info__description">效法羲和御天马，志在长空牧群星</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog<div class="twopeople"><div class="twopeople"><div class="container"style="height:200px;"><canvas class="illo"width="800"height="800"style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://cdn.guole.fun/js/twopeople1.js"></script><script src="https://cdn.guole.fun/js/zdog.dist.js"></script><script id="rendered-js"src="https://cdn.guole.fun/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">函数的定义与声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.</span> <span class="toc-text">函数的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数参数的传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.4.</span> <span class="toc-text">变量的作用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">数组与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">数组元素做函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">数组名做函数参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">函数应用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">1.7.</span> <span class="toc-text">函数的递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数的嵌套调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">深入理解递归的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">递归的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E8%BF%9E%E7%BB%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.8.</span> <span class="toc-text">模拟连续发生的动作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E8%BF%9B%E8%A1%8C%E2%80%9C%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E2%80%9D"><span class="toc-number">1.8.1.</span> <span class="toc-text">利用递归进行“自动分析”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98%E8%AF%BE%E4%B8%80-%EF%BC%9A%E6%9E%9A%E4%B8%BE%E3%80%81%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">1.9.</span> <span class="toc-text">习题课一 ：枚举、模拟与递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">什么是指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">什么是指针变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">定义一个指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.3.1.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">指针变量的++--</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.4.</span> <span class="toc-text">数组与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">用指针访问数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.5.</span> <span class="toc-text">字符串与指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.6.</span> <span class="toc-text">再谈一维数组的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.7.</span> <span class="toc-text">指向二维数组的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.8.</span> <span class="toc-text">指针的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.</span> <span class="toc-text">指针与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.9.1.</span> <span class="toc-text">指针用作函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.9.2.</span> <span class="toc-text">指向符号常量的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.9.3.</span> <span class="toc-text">指针用作函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.9.4.</span> <span class="toc-text">静态局部变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">结构体与链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.1.</span> <span class="toc-text">什么是结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">结构体变量与函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">指向结构体的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">结构体数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E5%9C%B0%E5%88%9B%E5%BB%BA"><span class="toc-number">3.5.1.</span> <span class="toc-text">链表可以动态地创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E6%AD%A5%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">逐步建立链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">链表的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">约瑟夫问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/acwing-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="acwing 搜索与图论"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="acwing 搜索与图论"/></a><div class="content"><a class="title" href="/2023/03/27/acwing-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="acwing 搜索与图论">acwing 搜索与图论</a><time datetime="2023-03-27T07:47:00.000Z" title="发表于 2023-03-27 15:47:00">2023-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/09/week7/" title="week7"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="week7"/></a><div class="content"><a class="title" href="/2023/03/09/week7/" title="week7">week7</a><time datetime="2023-03-09T10:46:12.000Z" title="发表于 2023-03-09 18:46:12">2023-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/07/acwing-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="acwing 数据结构"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="acwing 数据结构"/></a><div class="content"><a class="title" href="/2023/03/07/acwing-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="acwing 数据结构">acwing 数据结构</a><time datetime="2023-03-07T08:31:43.000Z" title="发表于 2023-03-07 16:31:43">2023-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/28/week6/" title="week"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="week"/></a><div class="content"><a class="title" href="/2023/02/28/week6/" title="week">week</a><time datetime="2023-02-28T02:33:46.000Z" title="发表于 2023-02-28 10:33:46">2023-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/week4/" title="week4"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="week4"/></a><div class="content"><a class="title" href="/2023/02/15/week4/" title="week4">week4</a><time datetime="2023-02-15T11:27:53.000Z" title="发表于 2023-02-15 19:27:53">2023-02-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_top_img.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> senor</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'gs9b9a4SkTjapA5QqBUFf0k5-gzGzoHsz',
      appKey: 'S4PI8juxWB7QNRl45dl7y9GO',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="ture"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel"><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，联通线路托管于Coding"><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":100,"height":180},"mobile":{"show":false},"react":{"opacityDefault":0.7}});</script></body></html>